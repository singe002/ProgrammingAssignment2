mean
nxt
nxt()
play()
x <- c(1,2,3,4)
f <- function(v) { num <- 0; for(i in seq_along(c)) num<-num+c[i]; num}
f <- function(v) { num <- 0; for(i in seq_along(v)) num<-num+v[i]; num}
f(c)
f(x)
submit()
my_mean(c(4,5,10))
submit()
remainder(5)
remainder(11,5)
remainder(divisor = 11, num = 5)
remainder(4, div = 2)
args(remainder)
submit()
evaluate(sd,c(1.4, 3.6, 7.9, 8.8))
evaluate(function(x){x+1}, 6)
evaluate(function(x){x[1]},c(8,4,0))
evaluate(function(x){x[length(x)]},c(8,4,0))
?paste
paste("Programming","is","fun!")
submit()
submit()
play()
paste()
submit()
submit()
submit()
telegram("This is a pain")
submit()
submit()
submit()
"I" %p% "love"  %p "R!"
("I" %p% "love")  %p "R!"
submit()
infi()
info()
play()
nxt()
submit()
"I" %p% "love" %p% "R!"
library("swirl", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
swirl()
head(flags)
dim(flags)
class(flags)
cls_list <- lapply(flags,class)
cls_list
class(cls_list)
as,character(cls_list)
as.character(cls_list)
sapply(flags,class)
cls_vect M- sapply(flags,class)
cls_vect <- sapply(flags,class)
class(cls_vect)
sum(flags$orange)
flag_colors <- flags[,11:17]
head(flag_colors)
lapply(flag_colors,sum)
sapply(flag_colors,sum)
sapply(flag_colors,mean)
flag_shapes <- flags[,19:23]
lapply(flag_shapes,range)
shape_mat <- sapply(flag_shapes,range)
shape_mat
class(shape_mat)
unique(c(3,4,5,5,5,6,6))
unique_vals <- lapply(flags,unique)
unique_vals
lapply(unique_vals,length)
sapply(unique_vals,length)
sapple(flags,unique)
sapply(flags,unique)
lapply(unique_vals,function(elem) elem[2])
sapply(flags,unique)
play()
str(vapply)
vapply
?vapply
nxt()
vapply(flags,unique,numeric(1))
ok()
sapply(flags,class)
vapply(flags,class,character(1))
?tapply
table(flags$landmass)
table(flags$animate)
tapply(flags$animate,flags$landmass,mean)
tapply(flags$population,flags$red,summary)
tapply(flags$population,flags$landmass,summary)
library(datasets)
data("iris")
?iris
head(iris)
tapply(iris$Sepal.Length,Species,mean)
tapply(iris$Sepal.Length,iris.Species,mean)
s<- split(iris$Sepal.Length,iris.Species)
tapply(iris$Sepal.Length,iris$Species,mean)
colMeans(iris)
data("mtcars")
?mtcars
tapply(mtcars.mpg,mtcars.cyl,mean)
tapply(mtcars$mpg,mtcars$cyl,mean)
sapply(mtcars,cyl,mean)
lapply(mtcars,mean)
mean(mtcars$mpg,mtcars$cyl)
with(mtcars,tapply(mpg,cyl,mean))
apply(mtcars,2,mean)
sapply(split(mtcars$mpg,mtcars$cyl),mean)
s<-sapply(split(mtcars$mpg,mtcars$cyl),mean)
dim(s)
class(s)
s[1]-s[3]
debug(ls)
ls()
ok()
ls(s)
ok()
ok()
tapply(iris$Sepal.Length,iris$Species,mean)
debug
s
ji
pwd()
getwd()
library("/Users/phyllissinger/ProgrammingAssignment2")
source("/Users/phyllissinger/ProgrammingAssignment2/cachematrix.R")
cachematrix.R
source("/Users/phyllissinger/ProgrammingAssignment2")
source("/Users/phyllissinger/ProgrammingAssignment2/cachematrix.R")
setwd("~/ProgrammingAssignment2")
source("cachematrix.R")
str("cachematrix.R")
set <- function(y){
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y){
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) x << solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## cacheSolve computes the inverse of the special "matrix" from makeCacheMatrix.
# If the inverse has been calculated (and the "matrix" hasn't changed), then
# cacheSolve returns the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(m)
m
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y){
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) x << solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## cacheSolve computes the inverse of the special "matrix" from makeCacheMatrix.
# If the inverse has been calculated (and the "matrix" hasn't changed), then
# cacheSolve returns the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(m)
m
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y){
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) x << solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## cacheSolve computes the inverse of the special "matrix" from makeCacheMatrix.
# If the inverse has been calculated (and the "matrix" hasn't changed), then
# cacheSolve returns the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(m)
m
}
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y){
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) x << solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
source("/Users/phyllissinger/ProgrammingAssignment2/cachematrix.R")
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y){
x <<- y
m <<- NULL
}
get <- function() x
#  setsolve <- function(solve) x << solve
#  getsolve <- function() m
#   list(set = set, get = get,
#       setsolve = setsolve,
#       getsolve = getsolve)
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y){
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) x << solve
#  getsolve <- function() m
#   list(set = set, get = get,
#       setsolve = setsolve,
#       getsolve = getsolve)
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y){
x <<- y
m <<- NULL
}
get <- function() x
# setsolve <- function(solve) x << solve
#  getsolve <- function() m
list(set = set, get = get) #,
#       setsolve = setsolve,
#       getsolve = getsolve)
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y){
x <<- y
m <<- NULL
}
get <- function() x
# setsolve <- function(solve) x << solve
getsolve <- function() m
list(set = set, get = get) #,
#       setsolve = setsolve,
getsolve = getsolve)
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y){
x <<- y
m <<- NULL
}
get <- function() x
# setsolve <- function(solve) x << solve
getsolve <- function() m
list(set = set, get = get,
#       setsolve = setsolve,
getsolve = getsolve)
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y){
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) x << solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
submit()
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y){
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) x << solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y){
x <<- y
m <<- NULL
}
get <- function() x
#setsolve <- function(solve) x << solve
getsolve <- function() m
list(set = set, get = get,
#   setsolve = setsolve,
getsolve = getsolve)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(m)
m
}
a <- matrix(c(1,1,0,1),2,2)
a
solve(a)
inverse(a)
## makeCacheMatrix and cacheSolve together iteratively find the inverse
## of a matrix, or provide a message that it isn't invertible
## makeCacheMatrix is a function that makes a special "matrix" that can
# cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y){
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) x << solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## cacheSolve computes the inverse of the special "matrix" from makeCacheMatrix.
# If the inverse has been calculated (and the "matrix" hasn't changed), then
# cacheSolve returns the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(m)
m
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y){
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) x #<< solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y){
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m << solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
source("makeCacheMatrix.R")
source("/Users/phyllissinger/ProgrammingAssignment2/makeCacheMatrix.R")
m <- NULL
set <- function(y){
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m << solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setsolve <- function(solve) m <<- solve
getsolve <- function() m
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## cacheSolve computes the inverse of the special "matrix" from makeCacheMatrix.
# If the inverse has been calculated (and the "matrix" hasn't changed), then
# cacheSolve returns the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getsolve()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setsolve(m)
m
}
makeCacheMatrix(x=matrix(c(1,2,3,0,1,-1,0,0,1)))
cacheSolve(a,... )
cacheSolve(x=a)
